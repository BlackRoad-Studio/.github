name: Semantic Release
on:
  push:
    branches: [master, main]
  workflow_dispatch:

jobs:
  release:
    runs-on: [self-hosted, pi]
    if: "!contains(github.event.head_commit.message, '[skip release]') && !contains(github.event.head_commit.message, 'chore: bump')"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "blackroad-bot"
          git config user.email "blackroad.systems@gmail.com"

      - name: Analyze commits since last tag
        id: analyze
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline -20 --pretty=format:"%s")
          else
            COMMITS=$(git log "$LAST_TAG"..HEAD --oneline --pretty=format:"%s")
          fi

          if [ -z "$COMMITS" ]; then
            echo "No new commits since last release"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Determine release type
          if echo "$COMMITS" | grep -qi "BREAKING\|!:"; then
            BUMP="major"
          elif echo "$COMMITS" | grep -qiE "^feat(\(.+\))?:"; then
            BUMP="minor"
          elif echo "$COMMITS" | grep -qiE "^fix(\(.+\))?:|^perf(\(.+\))?:"; then
            BUMP="patch"
          else
            echo "No releasable commits (need feat/fix/perf/BREAKING)"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "bump=$BUMP" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT

      - name: Generate changelog + create release
        if: steps.analyze.outputs.should_release == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const bump = '${{ steps.analyze.outputs.bump }}';
            const commits = `${{ steps.analyze.outputs.commits }}`.split('\n').filter(Boolean);
            const lastTag = '${{ steps.analyze.outputs.last_tag }}' || 'v0.0.0';

            // Parse and bump version
            const [, major, minor, patch] = lastTag.match(/v?(\d+)\.(\d+)\.(\d+)/) || [,0,0,0];
            let newVer;
            if (bump === 'major') newVer = `${+major+1}.0.0`;
            else if (bump === 'minor') newVer = `${major}.${+minor+1}.0`;
            else newVer = `${major}.${minor}.${+patch+1}`;
            const tag = `v${newVer}`;

            // Build categorized changelog
            const sections = { 'ðŸš€ Features': [], 'ðŸ› Bug Fixes': [], 'âš¡ Performance': [], 'ðŸ”§ Other': [] };
            for (const c of commits) {
              if (/^feat/i.test(c)) sections['ðŸš€ Features'].push(c);
              else if (/^fix/i.test(c)) sections['ðŸ› Bug Fixes'].push(c);
              else if (/^perf/i.test(c)) sections['âš¡ Performance'].push(c);
              else sections['ðŸ”§ Other'].push(c);
            }
            let body = `## What's Changed\n\n`;
            for (const [title, items] of Object.entries(sections)) {
              if (items.length) body += `### ${title}\n${items.map(i => `- ${i}`).join('\n')}\n\n`;
            }
            body += `**Full Changelog:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/compare/${lastTag}...${tag}`;

            // Create release
            await github.rest.repos.createRelease({
              owner: context.repo.owner, repo: context.repo.repo,
              tag_name: tag, name: `Release ${tag}`,
              body, draft: false, prerelease: false,
              generate_release_notes: false
            });
            console.log(`âœ… Released ${tag} (${bump} bump)`);
